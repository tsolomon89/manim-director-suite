# -*- coding: utf-8 -*-
"""Untitled25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WfjSaz1caMHn7gfTDUizjaGG91Zm22VI
"""

# ======================================================================
# Colab Artifact — Fixed Complex Spiral Keyframes (v2)
# UI + Per‑Param Easing (incl. step) + Camera Modes + Space Warps
# Manim API & CLI (now with warps) + k1 Lock + "Warp Points" toggle + Auto Preview
# ======================================================================
# Paste into a Google Colab notebook and run cells top→down.

# ======================================================================
# Cell 1 — System setup (Colab)
# ======================================================================
import subprocess

subprocess.run(["sudo", "apt", "-qq", "update"], check=True)
subprocess.run(["sudo", "apt", "-qq", "install", "ffmpeg", "libcairo2-dev", "libpango1.0-dev", "-y"], check=True)
subprocess.run(["pip", "install", "-q", "numpy", "matplotlib", "ipywidgets", "manim"], check=True)

import os, json, math, functools, subprocess, tempfile
from dataclasses import dataclass, asdict
from typing import Dict, List, Callable, Optional, Tuple

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation
import ipywidgets as widgets
from IPython.display import display, clear_output, HTML

plt.rcParams["figure.dpi"] = 120

# ======================================================================
# Cell 2 — Math model, easing (incl. step), warps, caching
# ======================================================================

TAU = 2 * math.pi

# --- Easing -------------------------------------------------------------
class Ease:
    @staticmethod
    def linear(t): return t
    @staticmethod
    def ease_in(t): return t*t
    @staticmethod
    def ease_out(t): return 1 - (1-t)*(1-t)
    @staticmethod
    def smoothstep(t): return t*t*t*(t*(t*6 - 15) + 10)
    @staticmethod
    def step_end(t): return 0.0 if t < 1.0 else 1.0  # jump at end
    @staticmethod
    def step_mid(t): return 0.0 if t < 0.5 else 1.0  # jump at midpoint

EASERS: Dict[str, Callable[[float], float]] = {
    "linear": Ease.linear,
    "ease_in": Ease.ease_in,
    "ease_out": Ease.ease_out,
    "smoothstep": Ease.smoothstep,
    "step_end": Ease.step_end,
    "step_mid": Ease.step_mid,
}

def lerp(a, b, t):
    return a + (b - a) * t

# Numeric-aware dict lerp (only numeric keys are lerped)

def lerp_dict(a: Dict[str, float], b: Dict[str, float], t: float) -> Dict[str, float]:
    out = {}
    keys = set(a.keys()) | set(b.keys())
    for k in keys:
        av, bv = a.get(k), b.get(k)
        if isinstance(av, (int, float)) and isinstance(bv, (int, float)):
            out[k] = lerp(float(av), float(bv), t)
        else:
            out[k] = b.get(k, av)
    return out

# --- Parameters ---------------------------------------------------------
@dataclass
class Params:
    # Core
    Z: int = 710
    T: float = 1.9999
    q1: float = 7.05223
    q2: float = 0.0
    q_correction: int = 1  # 1 => corrected k1, 0 => raw q1
    # Scaling
    k2: float = 1.0
    l_func: float = 10.0  # kept for compatibility; cancels in k formula
    # Camera
    center_x: float = 0.0
    center_y: float = 0.0
    zoom: float = 15.0  # half-extent
    # Sampling
    cycles: int = 100  # N = cycles * Z
    # Style
    opacity: float = 0.7
    point_size: float = 1.0

    def to_dict(self):
        return asdict(self)

    @classmethod
    def from_dict(cls, d):
        base = cls()
        out = {}
        for k, v in d.items():
            if hasattr(base, k):
                out[k] = type(getattr(base, k))(v)
        return cls(**{**base.to_dict(), **out})

    def derived(self) -> Dict[str, float]:
        # k = ln(T * tau/2) / ln(tau)
        k = math.log(max(1e-300, self.T * TAU * 0.5)) / math.log(TAU)
        # d = |2 cos((tau/2) T)|
        d = abs(2 * math.cos(0.5 * TAU * self.T))
        d = max(d, 1e-12)
        # q = q1 * tau^q2
        q = self.q1 * (TAU ** self.q2)
        q = math.copysign(max(abs(q), 1e-12), q)
        # k1
        if self.q_correction == 0:
            k1 = self.q1
        else:
            denom = (q / 2.0) * d
            denom = math.copysign(max(abs(denom), 1e-12), denom)
            k1 = TAU / denom
        f = k1 * np.exp(1j * (TAU ** k))
        return dict(k=k, d=d, q=q, k1=k1, f=f)

# --- Warps (space warps) ------------------------------------------------
# Warps act on complex plane points; used for grid and optionally points.

def warp_identity(z: np.ndarray, **kw):
    return z

def warp_power(z: np.ndarray, alpha: float = 1.0, **kw):
    r = np.abs(z); th = np.angle(z)
    r2 = np.power(np.clip(r, 1e-15, None), alpha)
    return r2 * np.exp(1j * (alpha * th))

def warp_log(z: np.ndarray, base: float = math.e, **kw):
    return np.log(z + 0j) / math.log(base)

def warp_swirl(z: np.ndarray, strength: float = 0.4, **kw):
    r = np.abs(z); th = np.angle(z)
    return r * np.exp(1j * (th + strength * (r**2)))

def warp_mobius(z: np.ndarray, a=1+0j, b=0+0j, c=0+0j, d=1+0j, **kw):
    denom = c*z + d
    denom = np.where(np.abs(denom) < 1e-15, 1+0j, denom)
    return (a*z + b) / denom

WARP_FUNCS: Dict[str, Callable[..., np.ndarray]] = {
    "identity": warp_identity,
    "power": warp_power,
    "log": warp_log,
    "swirl": warp_swirl,
    "mobius": warp_mobius,
}

# --- Geometry cache ----------------------------------------------------
_geom_cache: Dict[str, Tuple[np.ndarray, np.ndarray]] = {}
_geom_keys = ["Z", "T", "q1", "q2", "q_correction", "k2", "l_func", "cycles"]


def _geom_signature(p: Params, ndigits: int = 8) -> str:
    d = p.to_dict()
    sig = {k: (round(float(d[k]), ndigits) if isinstance(d[k], (int,float)) else d[k]) for k in _geom_keys}
    return json.dumps(sig, sort_keys=True)

# ======================================================================
# Cell 3 — Sampling, grid helpers, diagnostics
# ======================================================================

def generate_n(Z: int, cycles: int) -> np.ndarray:
    N = int(max(1, cycles) * max(1, Z))
    return np.arange(N, dtype=int)

@functools.lru_cache(maxsize=2048)
def _residue_colors(Z: int) -> np.ndarray:
    hues = (np.arange(Z) % Z) / max(1, Z)
    return plt.cm.hsv(hues)


def compute_points_cached(p: Params) -> Tuple[np.ndarray, np.ndarray, Dict[str, float]]:
    key = _geom_signature(p)
    if key in _geom_cache:
        z, residues = _geom_cache[key]
        dv = p.derived()
        return z, residues, dv
    dv = p.derived()
    f = dv["f"]
    n = generate_n(p.Z, p.cycles)
    z = np.sin(n * f) * p.k2
    residues = (n % p.Z)
    _geom_cache[key] = (z, residues)
    return z, residues, dv

# Warped grid for visualization

def _make_grid(center, zoom, grid_lines=9):
    cx, cy = center
    extent = zoom
    xs = np.linspace(cx - extent, cx + extent, grid_lines)
    ys = np.linspace(cy - extent, cy + extent, grid_lines)
    H = [xs + 1j*y for y in ys]
    V = [x + 1j*ys for x in xs]
    return H, V


def _plot_warped_grid(ax, warp_name, warp_kwargs, center, zoom, grid_lines=9, alpha=0.15):
    H, V = _make_grid(center, zoom, grid_lines)
    wf = WARP_FUNCS.get(warp_name, warp_identity)
    for seg in H + V:
        wz = wf(seg, **(warp_kwargs or {}))
        ax.plot(np.real(wz), np.imag(wz), linewidth=0.7, alpha=alpha)

# ======================================================================
# Cell 4 — Keyframes, per‑param easing, camera, global settings
# ======================================================================

CAMERA_MODES = ["interpolate", "hold", "autofit"]

# Global settings toggles
LOCK_K1 = False
LOCK_K1_TARGET = 1.0
WARP_POINTS = True  # when False: only grid warps; points stay in original space

@dataclass
class KF:
    t: float
    params: Params
    camera: str = "interpolate"
    warp_name: str = "identity"
    warp_kwargs: Dict[str, float] = None
    ease_overrides: Dict[str, str] = None  # incoming segment per‑param easing

class Timeline:
    def __init__(self):
        self.kfs: List[KF] = []
        self.default_ease: str = "smoothstep"

    def add_kf(self, kf: KF):
        if kf.camera not in CAMERA_MODES:
            kf.camera = "interpolate"
        self.kfs.append(kf)
        self.kfs.sort(key=lambda k: k.t)

    def clear(self):
        self.kfs.clear()

    def duration(self) -> float:
        return self.kfs[-1].t if self.kfs else 0.0

    def _bracket(self, t: float) -> Tuple[KF, KF, float]:
        if t <= self.kfs[0].t:
            return self.kfs[0], self.kfs[0], 0.0
        if t >= self.kfs[-1].t:
            return self.kfs[-1], self.kfs[-1], 1.0
        for i in range(len(self.kfs)-1):
            a, b = self.kfs[i], self.kfs[i+1]
            if a.t <= t <= b.t:
                u = (t - a.t) / max(1e-12, (b.t - a.t))
                return a, b, u
        return self.kfs[-1], self.kfs[-1], 1.0

    def synthesize_params(self, t: float) -> Tuple[Params, Dict[str,str]]:
        if not self.kfs:
            return Params(), {}
        a, b, u = self._bracket(t)
        if a is b:
            p = a.params
            return (self._apply_locks(p), a.ease_overrides or {})
        ov = a.ease_overrides or {}
        edef = EASERS[self.default_ease]
        pa = a.params.to_dict(); pb = b.params.to_dict()
        out = {}
        for k in pa.keys() | pb.keys():
            av, bv = pa.get(k), pb.get(k)
            if not (isinstance(av, (int, float)) and isinstance(bv, (int, float))):
                out[k] = bv if k in pb else av
                continue
            efunc = EASERS.get(ov.get(k, self.default_ease), edef)
            uu = efunc(u)
            out[k] = lerp(float(av), float(bv), uu)
        # sanitize integer-like
        out["Z"] = int(round(out["Z"]))
        out["q_correction"] = int(round(out.get("q_correction", 1)))
        p = Params.from_dict(out)
        p = self._apply_locks(p)
        return p, ov

    @staticmethod
    def _apply_locks(p: Params) -> Params:
        global LOCK_K1, LOCK_K1_TARGET
        if not LOCK_K1:
            return p
        # Solve for q1 to maintain target k1 given T, q2, q_correction
        T = p.T; q2 = p.q2; qc = p.q_correction
        d = abs(2 * math.cos(0.5 * TAU * T)); d = max(d, 1e-12)
        if qc == 0:
            q1 = float(LOCK_K1_TARGET)
        else:
            # k1 = TAU / ((q/2)*d), q = q1 * TAU**q2
            # => q1 = (2*TAU) / (d * k1 * TAU**q2)
            denom = d * max(LOCK_K1_TARGET, 1e-12) * (TAU ** q2)
            q1 = (2 * TAU) / max(denom, 1e-12)
        q1 = float(np.clip(q1, 1e-12, 1e12))
        return Params.from_dict({**p.to_dict(), "q1": q1})

TIMELINE = Timeline()

# ======================================================================
# Cell 5 — Preview and timeline render (matplotlib)
# ======================================================================

def _effective_camera(p: Params, wname: str, wkw: dict, camera_mode: str, warp_points_flag: bool):
    if camera_mode != "autofit":
        return p.center_x, p.center_y, p.zoom
    z, residues, _ = compute_points_cached(p)
    wf = WARP_FUNCS.get(wname, warp_identity)
    base = wf(z, **(wkw or {})) if warp_points_flag else z
    x = np.real(base); y = np.imag(base)
    if x.size == 0:
        return p.center_x, p.center_y, p.zoom
    xmin, xmax = np.nanmin(x), np.nanmax(x)
    ymin, ymax = np.nanmin(y), np.nanmax(y)
    cx, cy = 0.5*(xmin+xmax), 0.5*(ymin+ymax)
    half = 0.55 * max(xmax-xmin, ymax-ymin, 1e-6)
    return cx, cy, max(half, 1e-3)


def preview_at_time(t: float, show_grid=True, warp_points_flag=True, log_widget: Optional[widgets.Output]=None):
    p, _ = TIMELINE.synthesize_params(t)
    a, b, u = TIMELINE._bracket(t)
    # warp selection + tween
    if a is not b and a.warp_name == b.warp_name:
        efunc = EASERS[TIMELINE.default_ease]
        wkw = lerp_dict(a.warp_kwargs or {}, b.warp_kwargs or {}, efunc(u))
        wname = a.warp_name
    else:
        wname = (a.warp_name if u < 0.5 else b.warp_name) if a is not b else a.warp_name
        wkw = (a.warp_kwargs if u < 0.5 else b.warp_kwargs) if a is not b else (a.warp_kwargs or {})
        wkw = wkw or {}

    cx, cy, zm = _effective_camera(p, wname, wkw, (a.camera if u < 0.5 else b.camera) if a is not b else a.camera, warp_points_flag)

    # Data
    z, residues, dv = compute_points_cached(p)
    wf = WARP_FUNCS.get(wname, warp_identity)
    zw = wf(z, **wkw) if warp_points_flag else z

    # Diagnostics: warn on small d or extreme k1
    if log_widget is not None:
        with log_widget:
            if dv.get('d', 1.0) < 1e-6:
                print(f"⚠️ d is very small ({dv['d']:.3e}); expect numerical sensitivity.")
            k1 = dv.get('k1', 0.0)
            if not np.isfinite(k1) or abs(k1) > 1e6:
                print(f"⚠️ k1 looks extreme ({k1}). Consider lock_k1 or adjust T/q2.")

    fig, ax = plt.subplots(figsize=(6,6))
    ax.set_aspect('equal')
    ax.set_xlim(cx - zm, cx + zm)
    ax.set_ylim(cy - zm, cy + zm)

    if show_grid:
        _plot_warped_grid(ax, wname, wkw, (cx, cy), zm)

    cols = _residue_colors(p.Z)
    c = cols[residues]
    ax.scatter(np.real(zw), np.imag(zw), s=p.point_size, c=c, alpha=p.opacity, linewidths=0)
    ax.set_xlabel("Real"); ax.set_ylabel("Imag")
    ax.set_title(f"t={t:.2f}  Z={p.Z}  warp={wname}  camera={ (a.camera if u < 0.5 else b.camera) if a is not b else a.camera }  warp_points={warp_points_flag}")
    plt.show()


def render_timeline_matplotlib(seconds=6, fps=30, show_grid=True, outfile="timeline.mp4", warp_points_flag=True, progress_cb=None):
    if not TIMELINE.kfs:
        print("No keyframes.")
        return
    T = max(seconds, TIMELINE.duration() or seconds)
    frames = int(T * fps)

    fig, ax = plt.subplots(figsize=(6,6))
    ax.set_aspect('equal')

    def draw(i):
        ax.clear(); ax.set_aspect('equal')
        t = (i / frames) * T
        p, _ = TIMELINE.synthesize_params(t)
        a, b, u = TIMELINE._bracket(t)
        # warp selection
        if a is not b and a.warp_name == b.warp_name:
            efunc = EASERS[TIMELINE.default_ease]
            wkw = lerp_dict(a.warp_kwargs or {}, b.warp_kwargs or {}, efunc(u))
            wname = a.warp_name
        else:
            wname = (a.warp_name if u < 0.5 else b.warp_name) if a is not b else a.warp_name
            wkw = (a.warp_kwargs if u < 0.5 else b.warp_kwargs) if a is not b else (a.warp_kwargs or {})
            wkw = wkw or {}

        cx, cy, zm = _effective_camera(p, wname, wkw, (a.camera if u < 0.5 else b.camera) if a is not b else a.camera, warp_points_flag)
        z, residues, _ = compute_points_cached(p)
        wf = WARP_FUNCS.get(wname, warp_identity)
        zw = wf(z, **wkw) if warp_points_flag else z

        ax.set_xlim(cx - zm, cx + zm)
        ax.set_ylim(cy - zm, cy + zm)
        if show_grid:
            _plot_warped_grid(ax, wname, wkw, (cx, cy), zm)
        cols = _residue_colors(p.Z)
        ax.scatter(np.real(zw), np.imag(zw), s=p.point_size, c=cols[residues], alpha=p.opacity, linewidths=0)
        ax.set_xlabel("Real"); ax.set_ylabel("Imag")
        ax.set_title(f"t={t:.2f} Z={p.Z} warp={wname} warp_points={warp_points_flag}")
        return []

    anim = animation.FuncAnimation(fig, draw, frames=frames, interval=1000/fps, blit=False)
    writer = animation.FFMpegWriter(fps=fps, bitrate=1800)
    anim.save(outfile, writer=writer, progress_callback=progress_cb)
    plt.close(fig)
    print(f"Saved {outfile}")

# ======================================================================
# Cell 6 — Manim renderers (API and CLI; CLI now supports warps & warp_points)
# ======================================================================

from manim import *
from manim.utils.color import rgb_to_color
import colorsys
config.renderer = "cairo"
config.media_embed = True
config.progress_bar = "none"
config.verbosity = "WARNING"

class TimelineScene(Scene):
    def __init__(self, seconds=6, fps=30, warp_points_flag=True, **kw):
        self.seconds = seconds
        self.warp_points_flag = warp_points_flag
        config.frame_rate = fps
        super().__init__(**kw)

    def construct(self):
        T = max(self.seconds, TIMELINE.duration() or self.seconds)
        dt = 1/24
        t = 0.0
        group = VGroup(); self.add(group)
        last = -1e9
        while t <= T + 1e-6:
            if t - last < 0.1:  # sparse updates
                t += dt; continue
            last = t
            p, _ = TIMELINE.synthesize_params(t)
            a, b, u = TIMELINE._bracket(t)
            # warp
            if a is not b and a.warp_name == b.warp_name:
                efunc = EASERS[TIMELINE.default_ease]
                wkw = lerp_dict(a.warp_kwargs or {}, b.warp_kwargs or {}, efunc(u))
                wname = a.warp_name
            else:
                wname = (a.warp_name if u < 0.5 else b.warp_name) if a is not b else a.warp_name
                wkw = (a.warp_kwargs if u < 0.5 else b.warp_kwargs) if a is not b else (a.warp_kwargs or {})
                wkw = wkw or {}

            # camera
            cx, cy, zm = _effective_camera(p, wname, wkw, (a.camera if u < 0.5 else b.camera) if a is not b else a.camera, self.warp_points_flag)

            # data (cached)
            z, residues, _ = compute_points_cached(p)
            wf = WARP_FUNCS.get(wname, warp_identity)
            zw = wf(z, **wkw) if self.warp_points_flag else z

            # convert to screen coords
            group.become(VGroup())
            Z = int(p.Z)
            cols = [rgb_to_color(colorsys.hsv_to_rgb((r % Z) / max(1, Z), 0.8, 0.9)) for r in range(Z)]
            xrad = config.frame_width / 2
            yrad = config.frame_height / 2
            sx = xrad / max(zm, 1e-6)
            sy = yrad / max(zm, 1e-6)
            X = (np.real(zw) - cx) * sx
            Y = (np.imag(zw) - cy) * sy
            pts = np.column_stack([X, Y, np.zeros_like(X)])

            residues_arr = residues
            for r in range(Z):
                mask = (residues_arr == r)
                if not np.any(mask):
                    continue
                arr = pts[mask]
                if arr.shape[0] < 2:
                    continue
                vm = VMobject()
                if arr.shape[0] > 200:
                    vm.set_points_as_corners(arr)
                else:
                    try:
                        vm.set_points_smoothly(arr)
                    except:
                        vm.set_points_as_corners(arr)
                vm.set_stroke(color=cols[r], width=1.2, opacity=p.opacity)
                group.add(vm)

            self.wait(0.1)
            t += dt


def render_timeline_manim_api(seconds=6, fps=30, quality="medium_quality", warp_points_flag=True):
    config.quality = quality
    scene = TimelineScene(seconds=seconds, fps=fps, warp_points_flag=warp_points_flag)
    scene.render()


def render_timeline_manim_cli(seconds=6, fps=30, quality="-qm", outfile="TimelineScene", warp_points_flag=True):
    tmpdir = tempfile.mkdtemp(prefix="timeline_")
    timeline_path = os.path.join(tmpdir, "timeline.json")
    py_path = os.path.join(tmpdir, "scene.py")

    # Dump timeline + settings
    kflist = []
    for k in TIMELINE.kfs:
        kflist.append({
            "t": k.t,
            "params": k.params.to_dict(),
            "camera": k.camera,
            "warp_name": k.warp_name,
            "warp_kwargs": k.warp_kwargs or {},
            "ease_overrides": k.ease_overrides or {},
        })
    blob = {
        "default_ease": TIMELINE.default_ease,
        "kfs": kflist,
        "settings": {
            "lock_k1": LOCK_K1,
            "lock_k1_target": LOCK_K1_TARGET,
            "warp_points": warp_points_flag,
        }
    }
    with open(timeline_path, "w") as f:
        json.dump(blob, f)

    scene_code = f"""
from manim import *
from manim.utils.color import rgb_to_color
import colorsys
import json, numpy as np, math

TAU = 2*math.pi

class Ease:
    @staticmethod
    def linear(t): return t
    @staticmethod
    def ease_in(t): return t*t
    @staticmethod
    def ease_out(t): return 1-(1-t)*(1-t)
    @staticmethod
    def smoothstep(t): return t*t*t*(t*(t*6-15)+10)
    @staticmethod
    def step_end(t): return 0.0 if t<1.0 else 1.0
    @staticmethod
    def step_mid(t): return 0.0 if t<0.5 else 1.0
EASERS = {{"linear":Ease.linear,"ease_in":Ease.ease_in,"ease_out":Ease.ease_out,"smoothstep":Ease.smoothstep,"step_end":Ease.step_end,"step_mid":Ease.step_mid}}

def lerp(a,b,t): return a + (b-a)*t

def lerp_dict(a,b,t):
    out={{}}
    for k in set(a)|set(b):
        av, bv = a.get(k), b.get(k)
        if isinstance(av,(int,float)) and isinstance(bv,(int,float)):
            out[k] = lerp(float(av), float(bv), t)
        else:
            out[k] = b.get(k,av)
    return out

# warps
import cmath

def warp_identity(z, **kw):
    return z

def warp_power(z, alpha=1.0, **kw):
    r = np.abs(z); th = np.angle(z)
    r2 = np.power(np.clip(r, 1e-15, None), alpha)
    return r2 * np.exp(1j * (alpha * th))

def warp_log(z, base=math.e, **kw):
    return np.log(z + 0j) / math.log(base)

def warp_swirl(z, strength=0.4, **kw):
    r = np.abs(z); th = np.angle(z)
    return r * np.exp(1j * (th + strength * (r**2)))

def warp_mobius(z, a=1+0j, b=0+0j, c=0+0j, d=1+0j, **kw):
    denom = c*z + d
    denom = np.where(np.abs(denom) < 1e-15, 1+0j, denom)
    return (a*z + b) / denom

WARP_FUNCS = {{"identity":warp_identity,"power":warp_power,"log":warp_log,"swirl":warp_swirl,"mobius":warp_mobius}}

class TimelineScene(Scene):
    def __init__(self, seconds={seconds}, fps={fps}, **kw):
        self.seconds=seconds
        config.frame_rate=fps
        super().__init__(**kw)

    def construct(self):
        with open(r"{timeline_path}","r") as f:
            blob=json.load(f)
        default_ease = blob.get("default_ease","smoothstep")
        settings = blob.get("settings",{{}})
        lock_k1 = settings.get("lock_k1", False)
        lock_k1_target = settings.get("lock_k1_target", 1.0)
        warp_points_flag = settings.get("warp_points", True)
        kfs = blob["kfs"]
        if not kfs:
            self.wait(0.5); return
        T = max(self.seconds, kfs[-1]["t"] if kfs else self.seconds)
        dt = 1/24
        t = 0.0
        group=VGroup(); self.add(group)

        def dval(T):
            return max(abs(2*math.cos(0.5*TAU*T)),1e-12)

        def derived_k1(T,q2,q1,qc):
            if int(qc)==0:
                return q1
            q = q1 * (TAU**q2)
            denom = max(abs((q/2.0)*dval(T)),1e-12)
            return TAU/denom

        def lock_q1(T,q2,qc,k1_target):
            if int(qc)==0: return float(k1_target)
            denom = dval(T) * max(k1_target,1e-12) * (TAU**q2)
            return float((2*TAU)/max(denom,1e-12))

        def p_lerp(a,b,u,ov):
            pa=a["params"]; pb=b["params"]
            out={{}}
            for k in set(pa)|set(pb):
                av=pa.get(k); bv=pb.get(k)
                if isinstance(av,(int,float)) and isinstance(bv,(int,float)):
                    efunc=EASERS.get(ov.get(k,default_ease), EASERS[default_ease])
                    uu=efunc(u)
                    out[k]=lerp(float(av),float(bv),uu)
                else:
                    out[k]=bv if k in pb else av
            out["Z"]=int(round(out["Z"]))
            out["q_correction"]=int(round(out.get("q_correction",1)))
            if lock_k1:
                out["q1"]=lock_q1(out["T"], out["q2"], out["q_correction"], lock_k1_target)
            return out

        def compute_points(p):
            Z=int(p["Z"]); cycles=int(p.get("cycles",100))
            N=max(1,cycles*Z)
            n=np.arange(N)
            # derived f using possibly locked q1
            k = math.log(max(1e-300, p["T"]*TAU*0.5))/math.log(TAU)
            d = dval(p["T"]) ; q = p["q1"]*(TAU**p["q2"])
            if int(p.get("q_correction",1))==0:
                k1=p["q1"]
            else:
                denom=(q/2.0)*d
                if abs(denom)<1e-12: denom=1e-12
                k1=TAU/denom
            f = k1*np.exp(1j*(TAU**k))
            z=np.sin(n*f)*p["k2"]
            residues=(n%Z)
            return z,residues

        def effective_camera(p,wname,wkw,cam):
            if cam!="autofit":
                return p["center_x"],p["center_y"],p["zoom"]
            z,res=compute_points(p)
            wf=WARP_FUNCS.get(wname, warp_identity)
            base=wf(z, **wkw) if warp_points_flag else z
            x=np.real(base); y=np.imag(base)
            if x.size==0: return p["center_x"],p["center_y"],p["zoom"]
            xmin,xmax=np.min(x),np.max(x)
            ymin,ymax=np.min(y),np.max(y)
            cx,cy=0.5*(xmin+xmax),0.5*(ymin+ymax)
            half=0.55*max(xmax-xmin,ymax-ymin,1e-6)
            return cx,cy,max(half,1e-3)

        last=-1e9
        while t<=T+1e-6:
            if t-last<0.1: t+=dt; continue
            last=t
            # bracket
            a=b=kfs[0]
            u=0.0
            for i in range(len(kfs)-1):
                A,B=kfs[i],kfs[i+1]
                if A["t"]<=t<=B["t"]:
                    a,b=A,B
                    u=(t-A["t"]) / max(1e-12,(B["t"]-A["t"]))
                    break
                else:
                    a,b=kfs[-1],kfs[-1]; u=1.0
            ov=a.get("ease_overrides",{{}})
            p=p_lerp(a,b,u,ov)
            cam=(a["camera"] if u<0.5 else b["camera"]) if a is not b else a["camera"]
            wname=(a["warp_name"] if u<0.5 else b["warp_name"]) if a is not b else a["warp_name"]
            if a is not b and a["warp_name"]==b["warp_name"]:
                wkw=lerp_dict(a.get("warp_kwargs",{{}}), b.get("warp_kwargs",{{}}), EASERS[default_ease](u))
                wname=a["warp_name"]
            else:
                wkw=(a.get("warp_kwargs",{{}}) if u<0.5 else b.get("warp_kwargs",{{}})) if a is not b else a.get("warp_kwargs",{{}})

            cx,cy,zm=effective_camera(p,wname,wkw,cam)

            z,residues=compute_points(p)
            wf=WARP_FUNCS.get(wname, warp_identity)
            zw=wf(z, **wkw) if warp_points_flag else z

            group.become(VGroup())
            Z=int(p["Z"])
            cols=[rgb_to_color(colorsys.hsv_to_rgb((r%Z)/max(1,Z),0.8,0.9) for r in range(Z)]
            sx=(config.frame_width*0.5)/max(zm,1e-6); sy=(config.frame_height*0.5)/max(zm,1e-6)
            X=(np.real(zw)-cx)*sx; Y=(np.imag(zw)-cy)*sy
            P=np.column_stack([X,Y,np.zeros_like(X)])
            for r in range(Z):
                m=(residues==r)
                if not np.any(m): continue
                arr=P[m]
                if arr.shape[0]<2: continue
                vm=VMobject()
                if arr.shape[0]>200:
                    vm.set_points_as_corners(arr)
                else:
                    try: vm.set_points_smoothly(arr)
                    except: vm.set_points_as_corners(arr)
                vm.set_stroke(color=cols[r], width=1.2, opacity=p["opacity"])
                group.add(vm)
            self.wait(0.1)
            t+=dt
"""
    with open(py_path, "w") as f:
        f.write(scene_code)

    cmd = ["manim", quality, "--renderer=cairo", "--progress_bar=none", "-o", outfile, py_path, "TimelineScene"]
    print("CLI:", " ".join(cmd))
    subprocess.run(cmd, check=True)
    print("CLI render complete.")

# ======================================================================
# Cell 7 — UI (adds: lock k1, warp points toggle, auto preview)
# ======================================================================

# Parameter widgets
w_Z = widgets.IntSlider(value=710, min=10, max=5000, step=1, description='Z')
w_T = widgets.FloatSlider(value=1.9999, min=1.0, max=2.0, step=1e-5, readout_format='.5f', description='T')
w_q1 = widgets.FloatSlider(value=7.05223, min=0.000001, max=20.0, step=0.0001, readout_format='.6f', description='q1')
w_q2 = widgets.FloatSlider(value=0.0, min=-6.0, max=6.0, step=0.1, description='q2')
w_qc = widgets.Checkbox(value=True, description='q_correction')
w_k2 = widgets.FloatSlider(value=1.0, min=0.01, max=5.0, step=0.01, description='k2')
w_lf = widgets.FloatSlider(value=10.0, min=2.0, max=20.0, step=0.5, description='l_func')

w_center_x = widgets.FloatSlider(value=0.0, min=-50.0, max=50.0, step=0.1, description='center_x')
w_center_y = widgets.FloatSlider(value=0.0, min=-50.0, max=50.0, step=0.1, description='center_y')
w_zoom = widgets.FloatSlider(value=15.0, min=0.5, max=100.0, step=0.5, description='zoom')

w_cycles = widgets.IntSlider(value=100, min=1, max=2000, step=1, description='cycles')
w_opacity = widgets.FloatSlider(value=0.7, min=0.05, max=1.0, step=0.05, description='opacity')
w_point = widgets.FloatSlider(value=1.0, min=0.2, max=5.0, step=0.1, description='point_size')

# Easing controls
w_default_ease = widgets.Dropdown(options=list(EASERS.keys()), value='smoothstep', description='Default ease')
param_names = ['Z','T','q1','q2','q_correction','k2','l_func','center_x','center_y','zoom','cycles','opacity','point_size']
per_param_ease = {name: widgets.Dropdown(options=['(default)']+list(EASERS.keys()), value='(default)', layout=widgets.Layout(width='130px')) for name in param_names}

# Warp controls
w_warp = widgets.Dropdown(options=list(WARP_FUNCS.keys()), value='identity', description='Warp')
w_warp_kwargs = widgets.Text(value='{}', description='warp kwargs', layout=widgets.Layout(width='60%'))
w_warp_points = widgets.Checkbox(value=True, description='Warp points too')

# Camera mode
w_camera = widgets.Dropdown(options=CAMERA_MODES, value='interpolate', description='Camera')

# Keyframes
w_t = widgets.FloatText(value=0.0, description='t (sec)')
btn_add = widgets.Button(description='Add keyframe', button_style='success')
btn_clear = widgets.Button(description='Clear all', button_style='danger')
btn_delete = widgets.Button(description='Delete selected', button_style='warning')

kf_list = widgets.Select(options=[], layout=widgets.Layout(height='140px', width='100%'))

# Preview & render controls
w_preview_t = widgets.FloatSlider(value=0.0, min=0.0, max=10.0, step=0.05, description='Preview t', continuous_update=False)
w_auto_preview = widgets.Checkbox(value=False, description='Auto preview on scrub')
btn_preview = widgets.Button(description='Preview', button_style='info')
w_show_grid = widgets.Checkbox(value=True, description='Grid')

w_secs = widgets.FloatText(value=6.0, description='Seconds')
w_fps = widgets.IntSlider(value=30, min=10, max=60, step=5, description='FPS')
btn_render_mat = widgets.Button(description='Render (matplotlib)', button_style='primary')
btn_render_api = widgets.Button(description='Render (Manim API)', button_style='primary')
btn_render_cli = widgets.Button(description='Render (Manim CLI)', button_style='primary')

# Export/Import keyframes
btn_export = widgets.Button(description='Export keyframes JSON')
w_import_area = widgets.Textarea(placeholder='Paste keyframes JSON here...', layout=widgets.Layout(width='100%', height='120px'))
btn_import = widgets.Button(description='Import keyframes JSON')

# Global settings: k1 lock
w_lock_k1 = widgets.Checkbox(value=False, description='Lock k1')
w_lock_k1_target = widgets.FloatText(value=1.0, description='k1 target')

log_out = widgets.Output()

# Runtime status + progress UI (added)
status_html = widgets.HTML(value="")
progress_bar = widgets.IntProgress(value=0, min=0, max=1, description='Idle', bar_style='')

def set_status(msg, kind='info'):
    colors = {'info':'#444','run':'#b26a00','ok':'#2b8a3e','err':'#a33'}
    status_html.value = f"<b style='color:{colors.get(kind,'#444')}'>{msg}</b>"

def set_progress(i, n):
    progress_bar.max = max(1, int(n))
    progress_bar.value = int(i)
    progress_bar.description = f"{progress_bar.value}/{progress_bar.max}"
    progress_bar.bar_style = '' if progress_bar.value < progress_bar.max else 'success'

ALL_BTNS = []

def _controls_disabled(flag: bool):
    for b in ALL_BTNS:
        try: b.disabled = flag
        except Exception: pass

# Helpers

def _collect_params_from_widgets() -> Params:
    return Params(
        Z=w_Z.value,
        T=w_T.value,
        q1=w_q1.value,
        q2=w_q2.value,
        q_correction=1 if w_qc.value else 0,
        k2=w_k2.value,
        l_func=w_lf.value,
        center_x=w_center_x.value,
        center_y=w_center_y.value,
        zoom=w_zoom.value,
        cycles=w_cycles.value,
        opacity=w_opacity.value,
        point_size=w_point.value,
    )


def _current_ease_overrides() -> Dict[str,str]:
    out = {}
    for k, dd in per_param_ease.items():
        v = dd.value
        if v != '(default)':
            out[k] = v
    return out


def _update_kf_list():
    if not TIMELINE.kfs:
        kf_list.options = []
        return
    opts = []
    for i, kf in enumerate(TIMELINE.kfs):
        p = kf.params
        opts.append((f"#{i} t={kf.t:.2f}s  T={p.T:.6f}  q1={p.q1:.4f}  Z={p.Z}  warp={kf.warp_name}  cam={kf.camera}", i))
    kf_list.options = opts
    w_preview_t.max = max(10.0, max(k.t for k in TIMELINE.kfs))

# Button handlers & bindings

def on_add_clicked(_):
    p = _collect_params_from_widgets()
    TIMELINE.default_ease = w_default_ease.value
    try:
        wkw = json.loads(w_warp_kwargs.value.strip()) if w_warp_kwargs.value.strip() else {}
    except Exception as e:
        wkw = {}
        with log_out: print(f"warp kwargs invalid JSON; using {{}}. {e}")
    kf = KF(t=w_t.value, params=p, camera=w_camera.value, warp_name=w_warp.value, warp_kwargs=wkw, ease_overrides=_current_ease_overrides())
    TIMELINE.add_kf(kf)
    _update_kf_list()
    with log_out: print(f"Added keyframe @ t={w_t.value:.3f}")


def on_delete_clicked(_):
    if not TIMELINE.kfs: return
    if not (kf_list.value or kf_list.value == 0): return
    idx = kf_list.value
    if 0 <= idx < len(TIMELINE.kfs):
        TIMELINE.kfs.pop(idx)
        _update_kf_list()
        with log_out: print(f"Deleted keyframe #{idx}")


def on_clear_clicked(_):
    TIMELINE.clear(); _update_kf_list()
    with log_out: print("Keyframes cleared.")


def on_preview_clicked(_=None):
    if not TIMELINE.kfs:
        with log_out: print("No keyframes."); return
    _controls_disabled(True)
    try:
        set_status("Previewing… ⏳", 'run')
        preview_at_time(w_preview_t.value, show_grid=w_show_grid.value, warp_points_flag=w_warp_points.value, log_widget=log_out)
        set_status("Preview done ✅", 'ok')
    except Exception as e:
        set_status("Preview error ❌", 'err')
        with log_out: print(f"Preview error: {e}")
        raise
    finally:
        _controls_disabled(False)


def on_preview_slider_change(change):
    if change['name'] == 'value' and w_auto_preview.value:
        on_preview_clicked()


def on_render_mat(_):
    if not TIMELINE.kfs:
        with log_out: print("No keyframes."); return
    _controls_disabled(True)
    try:
        set_status("Rendering (matplotlib)… ⏳", 'run')
        total_secs = max(w_secs.value, TIMELINE.duration() or w_secs.value)
        total_frames = int(total_secs * w_fps.value)
        progress_bar.min = 0; progress_bar.max = max(1, total_frames); progress_bar.value = 0
        progress_bar.bar_style = 'info'; progress_bar.description = f"0/{progress_bar.max}"
        def pcb(i, n):
            set_progress(i+1, n)
        render_timeline_matplotlib(seconds=w_secs.value, fps=w_fps.value, show_grid=w_show_grid.value, outfile="timeline.mp4", warp_points_flag=w_warp_points.value, progress_cb=pcb)
        set_status("Matplotlib render complete ✅", 'ok')
        progress_bar.bar_style = 'success'
    except Exception as e:
        set_status("Matplotlib render error ❌", 'err')
        with log_out: print(f"Matplotlib render error: {e}")
        raise
    finally:
        _controls_disabled(False)


def on_render_api(_):
    if not TIMELINE.kfs:
        with log_out: print("No keyframes."); return
    _controls_disabled(True)
    try:
        set_status("Rendering (Manim API)… ⏳", 'run')
        render_timeline_manim_api(seconds=w_secs.value, fps=w_fps.value, quality="medium_quality", warp_points_flag=w_warp_points.value)
        set_status("Manim API render complete ✅", 'ok')
    except Exception as e:
        set_status("Manim API render error ❌", 'err')
        with log_out: print(f"Manim API render error: {e}")
        raise
    finally:
        _controls_disabled(False)


def on_render_cli(_):
    if not TIMELINE.kfs:
        with log_out: print("No keyframes."); return
    _controls_disabled(True)
    try:
        set_status("Rendering (Manim CLI)… ⏳", 'run')
        progress_bar.bar_style = 'info'; progress_bar.description = 'manim CLI running'
        render_timeline_manim_cli(seconds=w_secs.value, fps=w_fps.value, quality="-qm", outfile="TimelineScene", warp_points_flag=w_warp_points.value)
        set_status("Manim CLI render complete ✅", 'ok')
        progress_bar.bar_style = 'success'
    except Exception as e:
        set_status("Manim CLI render error ❌", 'err')
        with log_out: print(f"Manim CLI render error: {e}")
        raise
    finally:
        _controls_disabled(False)


def on_export(_):
    blob = {
        "default_ease": TIMELINE.default_ease,
        "kfs": [
            {
                "t": k.t,
                "params": k.params.to_dict(),
                "camera": k.camera,
                "warp_name": k.warp_name,
                "warp_kwargs": k.warp_kwargs or {},
                "ease_overrides": k.ease_overrides or {},
            } for k in TIMELINE.kfs
        ],
        "settings": {
            "lock_k1": w_lock_k1.value,
            "lock_k1_target": w_lock_k1_target.value,
            "warp_points": w_warp_points.value,
        }
    }
    with log_out:
        clear_output(wait=True)
        print(json.dumps(blob, indent=2))


def on_import(_):
    txt = w_import_area.value.strip()
    if not txt:
        with log_out: print("Nothing to import."); return
    try:
        blob = json.loads(txt)
        TIMELINE.clear()
        TIMELINE.default_ease = blob.get("default_ease", "smoothstep")
        for k in blob.get("kfs", []):
            TIMELINE.add_kf(KF(
                t=float(k["t"]),
                params=Params.from_dict(k["params"]),
                camera=k.get("camera", "interpolate"),
                warp_name=k.get("warp_name", "identity"),
                warp_kwargs=k.get("warp_kwargs", {}),
                ease_overrides=k.get("ease_overrides", {})
            ))
        # settings
        s = blob.get("settings", {})
        w_lock_k1.value = bool(s.get("lock_k1", False))
        w_lock_k1_target.value = float(s.get("lock_k1_target", 1.0))
        w_warp_points.value = bool(s.get("warp_points", True))
        _update_kf_list()
        with log_out: print(f"Imported {len(TIMELINE.kfs)} keyframes and settings.")
    except Exception as e:
        with log_out: print(f"Import error: {e}")

# Bindings
btn_add.on_click(on_add_clicked)
btn_delete.on_click(on_delete_clicked)
btn_clear.on_click(on_clear_clicked)

# Populate ALL_BTNS (added)
ALL_BTNS = [btn_preview, btn_render_mat, btn_render_api, btn_render_cli, btn_add, btn_delete, btn_clear, btn_export, btn_import]

btn_preview.on_click(on_preview_clicked)
btn_render_mat.on_click(on_render_mat)
btn_render_api.on_click(on_render_api)
btn_render_cli.on_click(on_render_cli)
btn_export.on_click(on_export)
btn_import.on_click(on_import)
w_preview_t.observe(on_preview_slider_change)

# Settings sync
def _sync_settings(*_):
    global LOCK_K1, LOCK_K1_TARGET, WARP_POINTS
    LOCK_K1 = bool(w_lock_k1.value)
    LOCK_K1_TARGET = float(max(1e-12, w_lock_k1_target.value))
    WARP_POINTS = bool(w_warp_points.value)

for w in (w_lock_k1, w_lock_k1_target, w_warp_points):
    w.observe(lambda _: _sync_settings(), names='value')
_sync_settings()

# Layout
row_params1 = widgets.HBox([w_Z, w_T, w_q1, w_q2, w_qc])
row_params2 = widgets.HBox([w_k2, w_lf, w_cycles, w_opacity, w_point])
row_camera  = widgets.HBox([w_center_x, w_center_y, w_zoom])

rows = []
for i in range(0, len(param_names), 4):
    chunk = param_names[i:i+4]
    row = widgets.HBox([widgets.VBox([widgets.Label(k), per_param_ease[k]]) for k in chunk])
    rows.append(row)
per_param_box = widgets.VBox(rows)

accordion = widgets.Accordion(children=[per_param_box])
accordion.set_title(0, 'Per‑parameter easing overrides')

# Display
display(HTML('<h3>Complex Spiral — Keyframe Animation (Fixed Model, v2)</h3>'))

display(HTML('<h4>Parameters</h4>'))
display(row_params1, row_params2, row_camera)

display(HTML('<h4>Easing / Warp / Camera / Settings</h4>'))
display(widgets.HBox([w_default_ease, w_warp, w_warp_kwargs, w_warp_points, w_camera]))
display(widgets.HBox([w_lock_k1, w_lock_k1_target]))
display(accordion)

display(HTML('<h4>Keyframes</h4>'))
display(widgets.HBox([w_t, btn_add, btn_delete, btn_clear]))
display(kf_list)

display(HTML('<h4>Preview</h4>'))
display(widgets.HBox([w_preview_t, w_auto_preview, btn_preview, w_show_grid]))

display(HTML('<h4>Render</h4>'))
display(widgets.HBox([w_secs, w_fps]))
display(widgets.HBox([btn_render_mat, btn_render_api, btn_render_cli]))
# Status & Progress (added)
display(status_html)
display(progress_bar)

display(HTML('<h4>Export / Import</h4>'))
display(btn_export, w_import_area, btn_import)

display(log_out)

print("UI ready. Add keyframes, scrub preview (auto optional), then render.")

