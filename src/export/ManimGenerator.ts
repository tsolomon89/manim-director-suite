/**
 * ManimGenerator - Generate Manim Python scripts from project state
 * Phase 7: Rendering & Export
 */

import type { Keyframe } from '../timeline/types';
import type { Parameter } from '../engine/types';
import type { FunctionDefinition } from '../engine/expression-types';
import type { CameraState } from '../scene/types';

export interface ManimExportOptions {
  resolution: '720p' | '1080p' | '1440p' | '4k';
  fps: number;
  quality: 'draft' | 'medium' | 'high';
  backgroundColor: string;
}

/**
 * Generate Manim Python script from keyframes and parameters
 */
export class ManimGenerator {
  /**
   * Generate complete Manim scene script
   */
  static generateScript(
    keyframes: Keyframe[],
    parameters: Parameter[],
    _functions: FunctionDefinition[],
    camera: CameraState,
    options: ManimExportOptions
  ): string {
    const script: string[] = [];

    // Header and imports
    script.push('"""');
    script.push('Generated by Parametric Keyframe Studio');
    script.push(`Resolution: ${options.resolution} @ ${options.fps}fps`);
    script.push(`Quality: ${options.quality}`);
    script.push('"""');
    script.push('');
    script.push('from manim import *');
    script.push('');

    // Scene class
    script.push('class ParametricAnimation(Scene):');
    script.push('    def construct(self):');

    // Background color
    script.push(`        self.camera.background_color = "${options.backgroundColor}"`);
    script.push('');

    // Set up axes based on camera bounds
    const xRange = this.calculateAxisRange(camera, 'x');
    const yRange = this.calculateAxisRange(camera, 'y');

    script.push('        # Create axes');
    script.push(`        axes = Axes(`);
    script.push(`            x_range=[${xRange.min}, ${xRange.max}, ${xRange.step}],`);
    script.push(`            y_range=[${yRange.min}, ${yRange.max}, ${yRange.step}],`);
    script.push(`            axis_config={`);
    script.push(`                "color": WHITE,`);
    script.push(`            }`);
    script.push(`        )`);
    script.push('        self.add(axes)');
    script.push('');

    // Initial parameter values (from first keyframe or defaults)
    script.push('        # Initialize parameters');
    const paramMap = new Map(parameters.map(p => [p.id, p]));
    for (const param of parameters) {
      const value = typeof param.value === 'number' ? param.value : (Array.isArray(param.value) ? param.value[0] ?? 0 : 0);
      script.push(`        ${param.name} = ValueTracker(${value})`);
    }
    script.push('');

    // Sort keyframes by time
    const sortedKeyframes = [...keyframes].sort((a, b) => a.time - b.time);

    if (sortedKeyframes.length === 0) {
      // No animation, just show static scene
      script.push('        # No keyframes - static scene');
      script.push('        self.wait(2)');
    } else {
      // Generate animations between keyframes
      for (let i = 0; i < sortedKeyframes.length - 1; i++) {
        const fromKf = sortedKeyframes[i];
        const toKf = sortedKeyframes[i + 1];
        const duration = toKf.time - fromKf.time;

        script.push(`        # Keyframe transition: ${fromKf.label || `t=${fromKf.time}`} â†’ ${toKf.label || `t=${toKf.time}`}`);
        script.push(`        # Duration: ${duration.toFixed(2)}s`);

        // Collect parameter animations
        const animations: string[] = [];

        if (toKf.snapshot.parameters) {
          for (const [paramId, paramSnap] of Object.entries(toKf.snapshot.parameters)) {
            if (!paramSnap.include) continue; // Skip if not included in tween

            const param = paramMap.get(paramId);
            if (!param) continue;

            const targetValue = paramSnap.value;

            animations.push(`            ${param.name}.animate.set_value(${targetValue})`);
          }
        }

        // Camera animation
        if (toKf.snapshot.camera && toKf.snapshot.camera.include) {
          const camSnap = toKf.snapshot.camera;
          // Manim camera scaling (approximate)
          const frameWidth = 14.0 / camSnap.zoom; // Manim default frame width is 14
          animations.push(`            self.camera.frame.animate.set(width=${frameWidth})`);
          animations.push(`            self.camera.frame.animate.move_to([${camSnap.x}, ${camSnap.y}, 0])`);
        }

        if (animations.length > 0) {
          script.push('        self.play(');
          script.push(animations.join(',\n'));
          script.push(`            run_time=${duration},`);
          script.push(`            rate_func=${this.mapEasingToManim(toKf.snapshot.parameters?.[Object.keys(toKf.snapshot.parameters)[0]]?.easing || 'linear')}`);
          script.push('        )');
        } else {
          script.push(`        self.wait(${duration})`);
        }
        script.push('');
      }

      // Final hold
      script.push('        # Final hold');
      script.push('        self.wait(1)');
    }

    return script.join('\n');
  }

  /**
   * Calculate axis range from camera state
   */
  private static calculateAxisRange(camera: CameraState, axis: 'x' | 'y'): { min: number; max: number; step: number } {
    const viewport = 14.0 / camera.zoom; // Manim default frame width
    const center = axis === 'x' ? camera.x : camera.y;

    const min = center - viewport / 2;
    const max = center + viewport / 2;
    const step = viewport / 10; // 10 tick marks

    return {
      min: parseFloat(min.toFixed(2)),
      max: parseFloat(max.toFixed(2)),
      step: parseFloat(step.toFixed(2)),
    };
  }

  /**
   * Map our easing names to Manim rate functions
   */
  private static mapEasingToManim(easingId: string = 'linear'): string {
    const mapping: Record<string, string> = {
      'linear': 'linear',
      'smoothstep': 'smooth',
      'ease-in': 'ease_in_cubic',
      'ease-out': 'ease_out_cubic',
      'ease-in-out': 'ease_in_out_cubic',
      'ease-in-sine': 'ease_in_sine',
      'ease-out-sine': 'ease_out_sine',
      'ease-in-quad': 'ease_in_quad',
      'ease-out-quad': 'ease_out_quad',
    };

    return mapping[easingId] || 'linear';
  }

  /**
   * Generate filename for the script
   */
  static generateScriptFilename(projectName: string = 'animation'): string {
    const safe = projectName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    return `${safe}_manim.py`;
  }

  /**
   * Get Manim CLI command for rendering
   */
  static getManimCommand(
    scriptPath: string,
    options: ManimExportOptions
  ): string {
    const qualityFlags: Record<string, string> = {
      'draft': '-ql',   // Low quality
      'medium': '-qm',  // Medium quality
      'high': '-qh',    // High quality
    };

    const flag = qualityFlags[options.quality] || '-qm';

    // Manim command format: manim -ql script.py SceneName
    return `manim ${flag} "${scriptPath}" ParametricAnimation`;
  }
}
