/**
 * Manim Fractal Exporter
 *
 * Generates Manim Python code for fractal rendering
 * Compatible with manim-community newton_fractal mobject
 */

import type { FractalFunction } from '../engine/fractal-types';
import type { Complex } from '../engine/complex-types';

export interface ManimFractalExportOptions {
  resolution: '720p' | '1080p' | '1440p' | '4k';
  fps: number;
  quality: 'draft' | 'medium' | 'high';
  backgroundColor: string;
  animateDuration?: number; // If animating fractal parameters
}

export class ManimFractalExporter {
  /**
   * Generate Manim script for a single fractal
   */
  static generateFractalScript(
    fractal: FractalFunction,
    options: ManimFractalExportOptions
  ): string {
    const script: string[] = [];

    // Header
    script.push('"""');
    script.push(`Fractal: ${fractal.lhs.fullName}`);
    script.push(`Type: ${fractal.fractalType}`);
    script.push(`Generated by Parametric Keyframe Studio`);
    script.push('"""');
    script.push('');
    script.push('from manim import *');
    script.push('import numpy as np');
    script.push('');

    // Scene class
    script.push(`class ${this.sanitizeClassName(fractal.lhs.fullName)}Scene(Scene):`);
    script.push('    def construct(self):');
    script.push(`        self.camera.background_color = "${options.backgroundColor}"`);
    script.push('');

    // Generate fractal-specific code
    if (fractal.fractalType === 'newton') {
      script.push(...this.generateNewtonFractal(fractal, options));
    } else if (fractal.fractalType === 'mandelbrot' || fractal.fractalType === 'julia') {
      script.push(...this.generateMandelbrotJulia(fractal, options));
    } else {
      script.push('        # Custom fractal - requires manual implementation');
    }

    return script.join('\n');
  }

  /**
   * Generate Newton fractal code
   */
  private static generateNewtonFractal(
    fractal: FractalFunction,
    options: ManimFractalExportOptions
  ): string[] {
    const script: string[] = [];
    const config = fractal.newtonConfig;

    if (!config) {
      script.push('        # ERROR: Missing Newton fractal configuration');
      return script;
    }

    // Create complex plane
    script.push('        # Set up complex plane');
    script.push('        plane = ComplexPlane(');
    script.push('            x_range=[-2, 2, 0.5],');
    script.push('            y_range=[-2, 2, 0.5],');
    script.push('        )');
    script.push('');

    // Define polynomial coefficients as complex numbers
    script.push('        # Polynomial coefficients (complex)');
    const coeffs = config.coefficients || [];
    script.push('        coefs = [');
    for (const coef of coeffs) {
      script.push(`            complex(${coef.real}, ${coef.imag}),`);
    }
    script.push('        ]');
    script.push('');

    // Define roots (for coloring)
    if (config.roots && config.roots.length > 0) {
      script.push('        # Roots (for coloring)');
      script.push('        roots = [');
      for (const root of config.roots) {
        script.push(`            complex(${root.real}, ${root.imag}),`);
      }
      script.push('        ]');
      script.push('');
    }

    // Define root colors
    script.push('        # Root colors');
    script.push('        colors = [');
    for (const color of config.rootColors) {
      script.push(`            "${color}",`);
    }
    script.push('        ]');
    script.push('');

    // Create Newton fractal mobject
    script.push('        # Create Newton fractal');
    script.push('        fractal = NewtonFractal(');
    script.push('            plane,');
    script.push('            coefs=coefs,');
    script.push('            colors=colors,');
    script.push(`            n_steps=${fractal.renderConfig.maxIterations},`);
    script.push('            saturation_factor=0.5,');
    script.push(`            black_for_cycles=${config.blackForCycles ? 'True' : 'False'},`);
    script.push('        )');
    script.push('');

    // Display
    script.push('        # Display fractal');
    script.push('        self.add(fractal)');
    script.push('        self.wait(2)');
    script.push('');

    // Animate zoom (optional)
    if (options.animateDuration && options.animateDuration > 0) {
      script.push('        # Animate zoom');
      script.push(`        self.play(`);
      script.push(`            plane.animate.scale(0.5),`);
      script.push(`            run_time=${options.animateDuration}`);
      script.push('        )');
      script.push('        self.wait(1)');
    }

    return script;
  }

  /**
   * Generate Mandelbrot/Julia set code
   */
  private static generateMandelbrotJulia(
    fractal: FractalFunction,
    options: ManimFractalExportOptions
  ): string[] {
    const script: string[] = [];
    const config = fractal.mandelbrotJuliaConfig;

    if (!config) {
      script.push('        # ERROR: Missing Mandelbrot/Julia configuration');
      return script;
    }

    const isJulia = fractal.fractalType === 'julia';

    // Create complex plane
    script.push('        # Set up complex plane');
    if (isJulia) {
      script.push('        # Julia set - zoom in on interesting region');
      script.push('        plane = ComplexPlane(');
      script.push('            x_range=[-2, 2, 0.5],');
      script.push('            y_range=[-2, 2, 0.5],');
      script.push('        )');
    } else {
      script.push('        # Mandelbrot set - standard view');
      script.push('        plane = ComplexPlane(');
      script.push('            x_range=[-2.5, 1, 0.5],');
      script.push('            y_range=[-1, 1, 0.5],');
      script.push('        )');
    }
    script.push('');

    // Custom Mandelbrot/Julia implementation (since manim doesn't have built-in)
    script.push('        # Custom fractal shader implementation');
    script.push('        # Note: Requires custom shader or pixel-by-pixel calculation');
    script.push('');

    script.push('        def mandelbrot_iteration(c, max_iter):');
    script.push('            """Calculate Mandelbrot iteration count"""');
    script.push('            z = complex(0, 0)');
    script.push('            for n in range(max_iter):');
    script.push(`                if abs(z) > ${fractal.renderConfig.escapeRadius || 2}:`);
    script.push('                    return n');
    script.push(`                z = z**${config.power || 2} + c`);
    script.push('            return max_iter');
    script.push('');

    if (isJulia && config.juliaParameter) {
      const jp = config.juliaParameter;
      script.push('        def julia_iteration(z, max_iter):');
      script.push('            """Calculate Julia iteration count"""');
      script.push(`            c = complex(${jp.real}, ${jp.imag})`);
      script.push('            for n in range(max_iter):');
      script.push(`                if abs(z) > ${fractal.renderConfig.escapeRadius || 2}:`);
      script.push('                    return n');
      script.push(`                z = z**${config.power || 2} + c`);
      script.push('            return max_iter');
      script.push('');
    }

    // Color mapping
    script.push('        def get_color(iterations, max_iter):');
    script.push('            """Map iteration count to color"""');
    script.push('            if iterations == max_iter:');
    script.push(`                return "${config.colorMap.insideColor}"`);
    script.push('            ');
    script.push('            # Normalized value');
    script.push('            t = iterations / max_iter');
    script.push('            ');
    script.push('            # Color scale interpolation');
    script.push('            colors = [');
    for (const color of config.colorMap.colorScale) {
      script.push(`                "${color}",`);
    }
    script.push('            ]');
    script.push('            ');
    script.push('            idx = int(t * (len(colors) - 1))');
    script.push('            return colors[idx]');
    script.push('');

    // Generate pixel grid
    script.push('        # Generate fractal pixels');
    script.push(`        resolution = 400  # Adjust for quality`);
    script.push(`        max_iterations = ${fractal.renderConfig.maxIterations}`);
    script.push('');

    script.push('        pixels = VGroup()');
    script.push('        for x in range(resolution):');
    script.push('            for y in range(resolution):');
    script.push('                # Map pixel to complex plane');
    script.push('                c_real = -2.5 + (x / resolution) * 3.5');
    script.push('                c_imag = -1 + (y / resolution) * 2');
    script.push('                c = complex(c_real, c_imag)');
    script.push('');
    script.push('                # Calculate iteration count');
    if (isJulia) {
      script.push('                iters = julia_iteration(c, max_iterations)');
    } else {
      script.push('                iters = mandelbrot_iteration(c, max_iterations)');
    }
    script.push('');
    script.push('                # Get color and create pixel');
    script.push('                color = get_color(iters, max_iterations)');
    script.push('                pixel = Dot(');
    script.push('                    point=plane.n2p(c),');
    script.push('                    radius=0.01,');
    script.push('                    color=color');
    script.push('                )');
    script.push('                pixels.add(pixel)');
    script.push('');

    script.push('        # Display fractal');
    script.push('        self.add(pixels)');
    script.push('        self.wait(2)');

    script.push('');
    script.push('        # NOTE: For better performance, consider using custom shaders');
    script.push('        # or the manim-physics extension for fractal rendering');

    return script;
  }

  /**
   * Generate script with multiple fractals
   */
  static generateMultiFractalScript(
    fractals: FractalFunction[],
    options: ManimFractalExportOptions
  ): string {
    const script: string[] = [];

    // Header
    script.push('"""');
    script.push(`Multiple Fractals: ${fractals.length} fractals`);
    script.push(`Generated by Parametric Keyframe Studio`);
    script.push('"""');
    script.push('');
    script.push('from manim import *');
    script.push('import numpy as np');
    script.push('');

    // Generate a scene class for each fractal
    for (let i = 0; i < fractals.length; i++) {
      const fractal = fractals[i];
      const className = `Fractal${i + 1}_${this.sanitizeClassName(fractal.lhs.fullName)}`;

      script.push(`class ${className}(Scene):`);
      script.push('    def construct(self):');
      script.push(`        self.camera.background_color = "${options.backgroundColor}"`);

      if (fractal.fractalType === 'newton') {
        script.push(...this.generateNewtonFractal(fractal, options).map(line => '    ' + line));
      } else if (fractal.fractalType === 'mandelbrot' || fractal.fractalType === 'julia') {
        script.push(...this.generateMandelbrotJulia(fractal, options).map(line => '    ' + line));
      }

      script.push('');
    }

    return script.join('\n');
  }

  /**
   * Sanitize class name (remove special characters)
   */
  private static sanitizeClassName(name: string): string {
    return name
      .replace(/[^a-zA-Z0-9_]/g, '_')
      .replace(/^[0-9]/, '_$&') // Can't start with number
      .replace(/__+/g, '_'); // Remove multiple underscores
  }

  /**
   * Get CLI command to render the scene
   */
  static getCliCommand(
    scriptPath: string,
    sceneClassName: string,
    options: ManimFractalExportOptions
  ): string {
    const qualityFlag = {
      draft: '-ql',
      medium: '-qm',
      high: '-qh',
    }[options.quality];

    const resolutionFlag = {
      '720p': '-r 1280,720',
      '1080p': '-r 1920,1080',
      '1440p': '-r 2560,1440',
      '4k': '-r 3840,2160',
    }[options.resolution];

    return `manim ${qualityFlag} ${resolutionFlag} --fps ${options.fps} "${scriptPath}" ${sceneClassName}`;
  }
}
