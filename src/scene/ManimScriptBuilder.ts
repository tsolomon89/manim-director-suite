/**
 * ManimScriptBuilder - Generate Manim Python scripts for single-frame rendering
 * Phase A: Manim Integration Foundation
 *
 * Generates Manim scripts that match our Canvas renderer output
 */

import type { CameraState } from './types';
import type { GridRenderConfig } from './GridConfig';
import type { PlottedFunction } from './FunctionPlotter';
import type { PlottedPoints } from './PointPlotter';
import type { ImplicitFunction } from './implicit-types';

export interface ManimSceneConfig {
  parameters: Record<string, number>;
  camera: CameraState;
  gridConfig: GridRenderConfig;
  functions: PlottedFunction[];
  points: PlottedPoints[];
  implicitFunctions: ImplicitFunction[];
  backgroundColor: string;
}

export interface ManimScriptOptions {
  quality: 'draft' | 'medium' | 'high';
  frameNumber?: number; // Specific frame to render (default: 0)
  outputName?: string;
}

/**
 * Build Manim Python scripts from scene state
 */
export class ManimScriptBuilder {
  /**
   * Generate complete Manim script for current scene state
   */
  static generateScript(config: ManimSceneConfig, options: ManimScriptOptions): string {
    const lines: string[] = [];

    // Header
    lines.push('"""');
    lines.push('Generated by Parametric Keyframe Studio - Single Frame Render');
    lines.push(`Quality: ${options.quality}`);
    lines.push(`Frame: ${options.frameNumber ?? 0}`);
    lines.push('"""');
    lines.push('');
    lines.push('from manim import *');
    lines.push('import numpy as np');
    lines.push('');

    // Scene class
    lines.push('class PreviewFrame(Scene):');
    lines.push('    def construct(self):');

    // Background color
    const bgColor = this.convertColor(config.backgroundColor);
    lines.push(`        self.camera.background_color = "${bgColor}"`);
    lines.push('');

    // Camera setup
    this.addCameraSetup(lines, config.camera);

    // Grid/Axes setup
    this.addGridSetup(lines, config.gridConfig, config.camera);

    // Parameters (as constants in this static frame)
    if (Object.keys(config.parameters).length > 0) {
      lines.push('        # Parameters');
      for (const [name, value] of Object.entries(config.parameters)) {
        lines.push(`        ${name} = ${value}`);
      }
      lines.push('');
    }

    // Functions
    if (config.functions.length > 0) {
      this.addFunctions(lines, config.functions, config.parameters);
    }

    // Points
    if (config.points.length > 0) {
      this.addPoints(lines, config.points, config.parameters);
    }

    // Implicit functions
    if (config.implicitFunctions.length > 0) {
      this.addImplicitFunctions(lines, config.implicitFunctions);
    }

    // No animation - just show static frame
    lines.push('        # Static frame - no animation');
    lines.push('        self.wait(0.1)  # Minimum wait for rendering');

    return lines.join('\n');
  }

  /**
   * Set up camera position and zoom
   */
  private static addCameraSetup(lines: string[], camera: CameraState): void {
    lines.push('        # Camera setup');

    // Manim uses frame width, not zoom factor
    // Our zoom=1 corresponds to Manim frame_width=14 (default)
    const frameWidth = 14.0 / camera.zoom;

    lines.push(`        self.camera.frame.set(width=${frameWidth.toFixed(4)})`);
    lines.push(`        self.camera.frame.move_to([${camera.x.toFixed(4)}, ${camera.y.toFixed(4)}, 0])`);
    lines.push('');
  }

  /**
   * Set up grid/axes
   */
  private static addGridSetup(lines: string[], gridConfig: GridRenderConfig, camera: CameraState): void {
    lines.push('        # Axes setup');

    // Calculate axis ranges based on camera and grid config
    const xRange = this.calculateAxisRange(camera, 'x', gridConfig);
    const yRange = this.calculateAxisRange(camera, 'y', gridConfig);

    const axesColor = this.convertColor(gridConfig.axes.color);

    lines.push(`        axes = Axes(`);
    lines.push(`            x_range=[${xRange.min}, ${xRange.max}, ${xRange.step}],`);
    lines.push(`            y_range=[${yRange.min}, ${yRange.max}, ${yRange.step}],`);
    lines.push(`            axis_config={`);
    lines.push(`                "color": ${axesColor},`);
    lines.push(`                "stroke_width": ${gridConfig.axes.width},`);
    lines.push(`            },`);
    lines.push(`            x_length=${(xRange.max - xRange.min) * camera.zoom},`);
    lines.push(`            y_length=${(yRange.max - yRange.min) * camera.zoom},`);
    lines.push(`        )`);

    if (gridConfig.showAxes) {
      lines.push('        self.add(axes)');
    }

    // Add grid lines
    if (gridConfig.showMajorGrid) {
      const gridColor = this.convertColor(gridConfig.majorGrid.color);
      lines.push('');
      lines.push('        # Grid lines');
      lines.push(`        grid = NumberPlane(`);
      lines.push(`            x_range=[${xRange.min}, ${xRange.max}, ${gridConfig.majorGrid.spacing}],`);
      lines.push(`            y_range=[${yRange.min}, ${yRange.max}, ${gridConfig.majorGrid.spacing}],`);
      lines.push(`            background_line_style={`);
      lines.push(`                "stroke_color": ${gridColor},`);
      lines.push(`                "stroke_width": ${gridConfig.majorGrid.width},`);
      lines.push(`                "stroke_opacity": ${gridConfig.majorGrid.opacity},`);
      lines.push(`            },`);
      lines.push(`            axis_config={"stroke_opacity": 0},  # Hide axes (we have separate Axes)`);
      lines.push(`        )`);
      lines.push('        self.add(grid)');
    }

    lines.push('');
  }

  /**
   * Calculate axis range from camera state
   */
  private static calculateAxisRange(
    camera: CameraState,
    axis: 'x' | 'y',
    gridConfig: GridRenderConfig
  ): { min: number; max: number; step: number } {
    const viewport = 14.0 / camera.zoom;
    const center = axis === 'x' ? camera.x : camera.y;

    const min = center - viewport / 2;
    const max = center + viewport / 2;
    const step = gridConfig.majorGrid?.spacing || 1.0;

    return {
      min: parseFloat(min.toFixed(2)),
      max: parseFloat(max.toFixed(2)),
      step: parseFloat(step.toFixed(2)),
    };
  }

  /**
   * Add function plots
   */
  private static addFunctions(
    lines: string[],
    functions: PlottedFunction[],
    parameters: Record<string, number>
  ): void {
    lines.push('        # Functions');

    for (const func of functions) {
      const color = this.convertColor(func.color);

      // Convert our expression to Python lambda
      // Replace parameter names with their values
      let expr = func.expression;
      for (const [paramName, paramValue] of Object.entries(parameters)) {
        // Only replace whole word matches
        const regex = new RegExp(`\\b${paramName}\\b`, 'g');
        expr = expr.replace(regex, paramValue.toString());
      }

      // Replace math.js syntax with Python/NumPy
      const independentVar = 'x'; // Default independent variable
      expr = this.convertExpressionToPython(expr, independentVar);

      lines.push(`        # Function ${func.id}`);
      lines.push(`        func_${func.id} = axes.plot(`);
      lines.push(`            lambda ${independentVar}: ${expr},`);
      lines.push(`            color=${color},`);
      lines.push(`            stroke_width=2,`);
      lines.push(`        )`);
      lines.push(`        self.add(func_${func.id})`);
    }

    lines.push('');
  }

  /**
   * Add point plots
   */
  private static addPoints(
    lines: string[],
    _points: PlottedPoints[],
    _parameters: Record<string, number>
  ): void {
    // TODO: Implement point plotting for Manim
    lines.push('        # Points (TODO: implement)');
    lines.push('');
  }

  /**
   * Add implicit function plots (contours)
   */
  private static addImplicitFunctions(
    lines: string[],
    _implicitFunctions: ImplicitFunction[]
  ): void {
    // TODO: Implement implicit function plotting for Manim (marching squares)
    lines.push('        # Implicit Functions (TODO: implement marching squares)');
    lines.push('');
  }

  /**
   * Convert our expression syntax to Python/NumPy
   */
  private static convertExpressionToPython(expr: string, _independentVar: string): string {
    // Replace math.js functions with NumPy equivalents
    let pythonExpr = expr;

    // Trigonometric functions (already compatible)
    // sin, cos, tan, etc. work in both

    // Power function
    pythonExpr = pythonExpr.replace(/\^/g, '**');

    // Absolute value
    pythonExpr = pythonExpr.replace(/abs\(/g, 'np.abs(');

    // Square root
    pythonExpr = pythonExpr.replace(/sqrt\(/g, 'np.sqrt(');

    // Exponential
    pythonExpr = pythonExpr.replace(/exp\(/g, 'np.exp(');

    // Logarithm
    pythonExpr = pythonExpr.replace(/log\(/g, 'np.log(');
    pythonExpr = pythonExpr.replace(/ln\(/g, 'np.log(');

    // Constants
    pythonExpr = pythonExpr.replace(/\bpi\b/g, 'np.pi');
    pythonExpr = pythonExpr.replace(/\be\b/g, 'np.e');

    return pythonExpr;
  }

  /**
   * Convert hex color to Manim color constant or hex
   */
  private static convertColor(hexColor: string): string {
    const colorMap: Record<string, string> = {
      '#FFFFFF': 'WHITE',
      '#000000': 'BLACK',
      '#FF0000': 'RED',
      '#00FF00': 'GREEN',
      '#0000FF': 'BLUE',
      '#FFFF00': 'YELLOW',
      '#FF00FF': 'PURPLE',
      '#00FFFF': 'TEAL',
      '#FFA500': 'ORANGE',
    };

    const upper = hexColor.toUpperCase();
    if (colorMap[upper]) {
      return colorMap[upper];
    }

    // Return as hex string
    return `"${hexColor}"`;
  }

  /**
   * Get output filename for rendered frame
   */
  static getOutputFilename(sceneName: string = 'PreviewFrame', frameNumber: number = 0): string {
    return `${sceneName}_${frameNumber.toString().padStart(4, '0')}.png`;
  }
}
